(ns crack.stacks_and_queues-test
  (:import (crack.stacks_and_queues Stack StackOfStacks))
  (:use clojure.test
        crack.stacks_and_queues))

(deftest a-test
  (testing "ch.3: stacks and queues"
    ;; Stack
    (let [s (stack)]
      (.push s 1)
      (.push s 5)
      (.push s 13)
      (is (= 3 (.size s)))
      (is (= 13 (.peek s)))
      (is (= 13 (.pop s)))
      (is (= 5 (.peek s)))
      (is (= 5 (.pop s)))
      (is (= 1 (.peek s)))
      (is (= 1 (.pop s)))
      (is (= nil (.peek s)))
      (is (= nil (.pop s)))
      )
    ;; p3.3 StackOfStacks
    (let [ss (sstack 2)]
      (.push ss 1)
      (is (= 1 (.peek ss)))
      (.push ss 5)
      (is (= 5 (.peek ss)))
      (.push ss 13)
      (is (= 3 (.size ss)))
      (.push ss 9)
      (.push ss 8)
      (is (= 5 (.size ss)))
      (is (= 8 (.pop ss)))
      (is (= 9 (.pop ss)))
      (is (= 13 (.pop ss)))
      (is (= 5 (.pop ss)))
      (is (= 1 (.pop ss)))
      (is (= nil (.peek ss)))
      (is (= nil (.pop ss)))
      (is (= 0 (.size ss)))
      )
    ;; p3.3b StackOfStacks
    (let [ss (sstack 2)]
      (.push ss 1)
      (.push ss 5)
      (.push ss 13)
      (.push ss 9)
      (.push ss 8)
      (is (= 9 (.popAt ss 1)))
      (is (= 5 (.popAt ss 2)))
      )
    ;; p3.3b StackOfStacks
    (let [towers { :l (stack) :m (stack) :r (stack) }]
      (.push (:l towers) 5)
      (.push (:l towers) 4)
      (.push (:l towers) 3)
      (.push (:l towers) 2)
      (.push (:l towers) 1)
      (is (= 5 (.size (:l towers))))
      ;(println towers)
      (hanoi towers :l :r :m 5)
      ;(println towers)
      (is (= 0 (.size (:l towers))))
      (is (= 0 (.size (:m towers))))
      (is (= 5 (.size (:r towers))))
      (is (= 1 (.pop (:r towers))))
      (is (= 2 (.pop (:r towers))))
      (is (= 3 (.pop (:r towers))))
      (is (= 4 (.pop (:r towers))))
      (is (= 5 (.pop (:r towers))))
      (is (= nil (.pop (:r towers))))
      )
    ))
